import os
import unittest
import logging
import vtk, qt, ctk, slicer
from slicer.ScriptedLoadableModule import *
from slicer.util import VTKObservationMixin


class TickSegmentationReview(ScriptedLoadableModule):
    """3D Slicer module for reviewing CT tick segmentations from MorphoVue"""

    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "Tick Segmentation Review"
        self.parent.categories = ["Segmentation"]
        self.parent.dependencies = []
        self.parent.contributors = ["MorphoVue Team"]
        self.parent.helpText = """
This module allows researchers to review and edit CT tick segmentations
generated by the YOLOv10 + MONAI pipeline (Local Mode).
"""
        self.parent.acknowledgementText = """
Developed for the CT Tick ML Platform (MorphoVue).
"""


class TickSegmentationReviewWidget(ScriptedLoadableModuleWidget, VTKObservationMixin):
    """UI widget for the module"""

    def __init__(self, parent=None):
        ScriptedLoadableModuleWidget.__init__(self, parent)
        VTKObservationMixin.__init__(self)
        self.logic = None
        self._parameterNode = None
        self._updatingGUIFromParameterNode = False

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        # Load widget from .ui file
        uiWidget = slicer.util.loadUI(self.resourcePath('UI/TickSegmentationReview.ui'))
        self.layout.addWidget(uiWidget)
        self.ui = slicer.util.childWidgetVariables(uiWidget)

        # Set scene in MRML widgets
        self.ui.inputSelector.setMRMLScene(slicer.mrmlScene)
        self.ui.segmentationSelector.setMRMLScene(slicer.mrmlScene)
        
        # Rename buttons for local mode
        self.ui.loadFromFirebaseButton.text = "Load from Local"
        self.ui.uploadToFirebaseButton.text = "Save to Local"

        # Create logic class
        self.logic = TickSegmentationReviewLogic()

        # Connections
        self.ui.loadFromFirebaseButton.connect('clicked(bool)', self.onLoadFromLocal)
        self.ui.uploadToFirebaseButton.connect('clicked(bool)', self.onSaveToLocal)
        self.ui.computeStatisticsButton.connect('clicked(bool)', self.onComputeStatistics)
        self.ui.exportMaskButton.connect('clicked(bool)', self.onExportMask)

        # Make sure parameter node is initialized
        self.initializeParameterNode()

    def cleanup(self):
        self.removeObservers()

    def initializeParameterNode(self):
        """Ensure parameter node exists"""
        self.setParameterNode(self.logic.getParameterNode())

    def setParameterNode(self, inputParameterNode):
        """Set and observe parameter node"""
        if inputParameterNode:
            self.logic.setDefaultParameters(inputParameterNode)

        if self._parameterNode is not None:
            self.removeObserver(self._parameterNode, vtk.vtkCommand.ModifiedEvent, self.updateGUIFromParameterNode)
        self._parameterNode = inputParameterNode
        if self._parameterNode is not None:
            self.addObserver(self._parameterNode, vtk.vtkCommand.ModifiedEvent, self.updateGUIFromParameterNode)

        self.updateGUIFromParameterNode()

    def updateGUIFromParameterNode(self, caller=None, event=None):
        """Update GUI when parameter node is modified"""
        if self._parameterNode is None or self._updatingGUIFromParameterNode:
            return

        self._updatingGUIFromParameterNode = True

        # Update buttons
        inputNode = self.ui.inputSelector.currentNode()
        segmentationNode = self.ui.segmentationSelector.currentNode()
        
        self.ui.computeStatisticsButton.enabled = (inputNode is not None and segmentationNode is not None)
        self.ui.exportMaskButton.enabled = segmentationNode is not None

        self._updatingGUIFromParameterNode = False

    def onLoadFromLocal(self):
        """Load scan and segmentation from local filesystem"""
        try:
            slicer.util.showStatusMessage("Select TIFF Scan...")
            
            scanPath = qt.QFileDialog.getOpenFileName(None, "Select CT Scan", "", "TIFF Files (*.tiff *.tif)")
            if not scanPath:
                return

            volumeNode = slicer.util.loadVolume(scanPath)
            self.ui.inputSelector.setCurrentNode(volumeNode)
            
            # Try to auto-discover mask in likely locations
            scanDir = os.path.dirname(scanPath)
            scanName = os.path.splitext(os.path.basename(scanPath))[0]
            
            # Check standard results structure: results/scan_name/mask.nrrd
            possible_mask_paths = [
                os.path.join(scanDir, "mask.nrrd"),
                os.path.join(scanDir, f"{scanName}_mask.nrrd"),
                os.path.join(os.path.dirname(scanDir), "results", scanName, "mask.nrrd")
            ]
            
            maskPath = None
            for p in possible_mask_paths:
                if os.path.exists(p):
                    maskPath = p
                    break
            
            if not maskPath:
                slicer.util.showStatusMessage("Select Segmentation Mask...")
                maskPath = qt.QFileDialog.getOpenFileName(None, "Select Segmentation Mask", os.path.dirname(scanPath), "NRRD Files (*.nrrd)")
            
            if maskPath:
                segmentationNode = slicer.util.loadSegmentation(maskPath)
                self.ui.segmentationSelector.setCurrentNode(segmentationNode)
                slicer.util.showStatusMessage("Loaded successfully", 3000)
            else:
                slicer.util.showStatusMessage("Scan loaded (no mask selected)", 3000)
                
        except Exception as e:
            slicer.util.errorDisplay("Failed to load: " + str(e))

    def onSaveToLocal(self):
        """Save corrected segmentation locally"""
        try:
            segmentationNode = self.ui.segmentationSelector.currentNode()
            if not segmentationNode:
                slicer.util.errorDisplay("Please select a segmentation")
                return

            outputPath = qt.QFileDialog.getSaveFileName(None, "Save Segmentation", "", "NRRD Files (*.nrrd)")
            if not outputPath:
                return
                
            slicer.util.saveNode(segmentationNode, outputPath)
            slicer.util.showStatusMessage("Segmentation saved to: " + outputPath, 5000)
            
            # Also prompt to save statistics if computed
            if slicer.util.confirmOkCancelDisplay("Do you want to save updated statistics to JSON?"):
                inputVolume = self.ui.inputSelector.currentNode()
                if inputVolume:
                    stats = self.logic.computeStatistics(inputVolume, segmentationNode)
                    jsonPath = os.path.splitext(outputPath)[0] + "_quantification.json"
                    import json
                    
                    # Format for JSON
                    json_stats = []
                    for segId, metrics in stats.items():
                        json_stats.append({
                            "organ_name": segId,
                            "volume": metrics['volume_mm3'],
                            "surface_area": metrics['surface_area_mm2'],
                            "centroid": metrics['centroid']
                        })
                    
                    with open(jsonPath, 'w') as f:
                        json.dump(json_stats, f, indent=2)
                    slicer.util.showStatusMessage(f"Saved stats to {jsonPath}", 3000)
            
        except Exception as e:
            slicer.util.errorDisplay("Failed to save: " + str(e))

    def onComputeStatistics(self):
        """Compute organ-level statistics"""
        try:
            inputVolume = self.ui.inputSelector.currentNode()
            segmentation = self.ui.segmentationSelector.currentNode()

            if not inputVolume or not segmentation:
                slicer.util.errorDisplay("Please select both input volume and segmentation")
                return

            slicer.util.showStatusMessage("Computing statistics...")
            
            # Compute statistics
            stats = self.logic.computeStatistics(inputVolume, segmentation)
            
            # Display results
            resultsText = "Segmentation Statistics:\n\n"
            for segmentId in stats:
                resultsText += f"{segmentId}:\n"
                resultsText += f"  Volume: {stats[segmentId]['volume_mm3']:.2f} mm³\n"
                resultsText += f"  Surface area: {stats[segmentId]['surface_area_mm2']:.2f} mm²\n"
                resultsText += f"  Centroid: {stats[segmentId]['centroid']}\n\n"
            
            self.ui.statisticsTextBrowser.plainText = resultsText
            
            slicer.util.showStatusMessage("Statistics computed", 3000)
        except Exception as e:
            slicer.util.errorDisplay("Failed to compute statistics: " + str(e))

    def onExportMask(self):
        """Export segmentation mask"""
        try:
            segmentationNode = self.ui.segmentationSelector.currentNode()
            if not segmentationNode:
                slicer.util.errorDisplay("Please select a segmentation")
                return

            outputPath = qt.QFileDialog.getSaveFileName(None, "Export Segmentation", "", "NRRD Files (*.nrrd)")
            if outputPath:
                slicer.util.saveNode(segmentationNode, outputPath)
                slicer.util.showStatusMessage("Exported to: " + outputPath, 3000)
        except Exception as e:
            slicer.util.errorDisplay("Failed to export: " + str(e))


class TickSegmentationReviewLogic(ScriptedLoadableModuleLogic):
    """Logic for the module"""

    def __init__(self):
        ScriptedLoadableModuleLogic.__init__(self)

    def setDefaultParameters(self, parameterNode):
        """Initialize parameter node with default values"""
        if not parameterNode.GetParameter("Threshold"):
            parameterNode.SetParameter("Threshold", "100.0")

    def computeStatistics(self, inputVolume, segmentation):
        """
        Compute statistics for each segment
        
        Returns:
            Dictionary with statistics for each segment
        """
        import SegmentStatistics
        
        segStatLogic = SegmentStatistics.SegmentStatisticsLogic()
        segStatLogic.getParameterNode().SetParameter("Segmentation", segmentation.GetID())
        segStatLogic.getParameterNode().SetParameter("ScalarVolume", inputVolume.GetID())
        
        # Compute statistics
        segStatLogic.computeStatistics()
        
        # Get results
        stats = {}
        statsTable = segStatLogic.getStatisticsTable()
        
        for rowIndex in range(statsTable.GetNumberOfRows()):
            segmentId = statsTable.GetValue(rowIndex, 0).ToString()
            
            # Centroid parsing (might fail if not available/computed)
            centroid = "N/A"
            
            stats[segmentId] = {
                'volume_mm3': float(statsTable.GetValue(rowIndex, 1).ToString()),
                'surface_area_mm2': float(statsTable.GetValue(rowIndex, 2).ToString()) if statsTable.GetNumberOfColumns() > 2 else 0,
                'centroid': centroid
            }
        
        return stats


class TickSegmentationReviewTest(ScriptedLoadableModuleTest):
    """Test case for the module"""

    def setUp(self):
        slicer.mrmlScene.Clear()

    def runTest(self):
        self.setUp()
        self.test_TickSegmentationReview1()

    def test_TickSegmentationReview1(self):
        self.delayDisplay("Starting the test")
        self.delayDisplay('Test passed')
