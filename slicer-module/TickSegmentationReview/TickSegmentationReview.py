import os
import unittest
import logging
import vtk, qt, ctk, slicer
from slicer.ScriptedLoadableModule import *
from slicer.util import VTKObservationMixin


class TickSegmentationReview(ScriptedLoadableModule):
    """3D Slicer module for reviewing CT tick segmentations from MorphoVue"""

    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "Tick Segmentation Review"
        self.parent.categories = ["Segmentation"]
        self.parent.dependencies = []
        self.parent.contributors = ["MorphoVue Team"]
        self.parent.helpText = """
This module allows researchers to review and edit CT tick segmentations
generated by the YOLOv10 + MONAI pipeline.
"""
        self.parent.acknowledgementText = """
Developed for the CT Tick ML Platform (MorphoVue).
"""


class TickSegmentationReviewWidget(ScriptedLoadableModuleWidget, VTKObservationMixin):
    """UI widget for the module"""

    def __init__(self, parent=None):
        ScriptedLoadableModuleWidget.__init__(self, parent)
        VTKObservationMixin.__init__(self)
        self.logic = None
        self._parameterNode = None
        self._updatingGUIFromParameterNode = False

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        # Load widget from .ui file
        uiWidget = slicer.util.loadUI(self.resourcePath('UI/TickSegmentationReview.ui'))
        self.layout.addWidget(uiWidget)
        self.ui = slicer.util.childWidgetVariables(uiWidget)

        # Set scene in MRML widgets
        self.ui.inputSelector.setMRMLScene(slicer.mrmlScene)
        self.ui.segmentationSelector.setMRMLScene(slicer.mrmlScene)

        # Create logic class
        self.logic = TickSegmentationReviewLogic()

        # Connections
        self.ui.loadFromFirebaseButton.connect('clicked(bool)', self.onLoadFromFirebase)
        self.ui.uploadToFirebaseButton.connect('clicked(bool)', self.onUploadToFirebase)
        self.ui.computeStatisticsButton.connect('clicked(bool)', self.onComputeStatistics)
        self.ui.exportMaskButton.connect('clicked(bool)', self.onExportMask)

        # Make sure parameter node is initialized
        self.initializeParameterNode()

    def cleanup(self):
        self.removeObservers()

    def initializeParameterNode(self):
        """Ensure parameter node exists"""
        self.setParameterNode(self.logic.getParameterNode())

    def setParameterNode(self, inputParameterNode):
        """Set and observe parameter node"""
        if inputParameterNode:
            self.logic.setDefaultParameters(inputParameterNode)

        if self._parameterNode is not None:
            self.removeObserver(self._parameterNode, vtk.vtkCommand.ModifiedEvent, self.updateGUIFromParameterNode)
        self._parameterNode = inputParameterNode
        if self._parameterNode is not None:
            self.addObserver(self._parameterNode, vtk.vtkCommand.ModifiedEvent, self.updateGUIFromParameterNode)

        self.updateGUIFromParameterNode()

    def updateGUIFromParameterNode(self, caller=None, event=None):
        """Update GUI when parameter node is modified"""
        if self._parameterNode is None or self._updatingGUIFromParameterNode:
            return

        self._updatingGUIFromParameterNode = True

        # Update buttons
        inputNode = self.ui.inputSelector.currentNode()
        segmentationNode = self.ui.segmentationSelector.currentNode()
        
        self.ui.computeStatisticsButton.enabled = (inputNode is not None and segmentationNode is not None)
        self.ui.exportMaskButton.enabled = segmentationNode is not None

        self._updatingGUIFromParameterNode = False

    def onLoadFromFirebase(self):
        """Load scan and segmentation from Firebase"""
        try:
            scanId = self.ui.scanIdLineEdit.text
            if not scanId:
                slicer.util.errorDisplay("Please enter a Scan ID")
                return

            slicer.util.showStatusMessage("Downloading from Firebase...")
            
            # TODO: Implement Firebase download
            # For now, show file dialog
            scanPath = qt.QFileDialog.getOpenFileName(None, "Select CT Scan", "", "TIFF Files (*.tiff *.tif)")
            if scanPath:
                volumeNode = slicer.util.loadVolume(scanPath)
                self.ui.inputSelector.setCurrentNode(volumeNode)
            
            maskPath = qt.QFileDialog.getOpenFileName(None, "Select Segmentation Mask", "", "NRRD Files (*.nrrd)")
            if maskPath:
                segmentationNode = slicer.util.loadSegmentation(maskPath)
                self.ui.segmentationSelector.setCurrentNode(segmentationNode)
            
            slicer.util.showStatusMessage("Loaded successfully", 3000)
        except Exception as e:
            slicer.util.errorDisplay("Failed to load: " + str(e))

    def onUploadToFirebase(self):
        """Upload corrected segmentation to Firebase"""
        try:
            segmentationNode = self.ui.segmentationSelector.currentNode()
            if not segmentationNode:
                slicer.util.errorDisplay("Please select a segmentation")
                return

            scanId = self.ui.scanIdLineEdit.text
            if not scanId:
                slicer.util.errorDisplay("Please enter a Scan ID")
                return

            # Save to temp file
            import tempfile
            tempDir = tempfile.gettempdir()
            outputPath = os.path.join(tempDir, f"{scanId}_corrected.nrrd")
            
            slicer.util.saveNode(segmentationNode, outputPath)
            
            slicer.util.showStatusMessage("Segmentation saved to: " + outputPath, 5000)
            
            # TODO: Implement Firebase upload
            slicer.util.infoDisplay(f"Segmentation saved to:\n{outputPath}\n\nUpload this file to Firebase manually or implement automatic upload.")
            
        except Exception as e:
            slicer.util.errorDisplay("Failed to upload: " + str(e))

    def onComputeStatistics(self):
        """Compute organ-level statistics"""
        try:
            inputVolume = self.ui.inputSelector.currentNode()
            segmentation = self.ui.segmentationSelector.currentNode()

            if not inputVolume or not segmentation:
                slicer.util.errorDisplay("Please select both input volume and segmentation")
                return

            slicer.util.showStatusMessage("Computing statistics...")
            
            # Compute statistics
            stats = self.logic.computeStatistics(inputVolume, segmentation)
            
            # Display results
            resultsText = "Segmentation Statistics:\n\n"
            for segmentId in stats:
                resultsText += f"{segmentId}:\n"
                resultsText += f"  Volume: {stats[segmentId]['volume_mm3']:.2f} mm³\n"
                resultsText += f"  Surface area: {stats[segmentId]['surface_area_mm2']:.2f} mm²\n"
                resultsText += f"  Centroid: {stats[segmentId]['centroid']}\n\n"
            
            self.ui.statisticsTextBrowser.plainText = resultsText
            
            slicer.util.showStatusMessage("Statistics computed", 3000)
        except Exception as e:
            slicer.util.errorDisplay("Failed to compute statistics: " + str(e))

    def onExportMask(self):
        """Export segmentation mask"""
        try:
            segmentationNode = self.ui.segmentationSelector.currentNode()
            if not segmentationNode:
                slicer.util.errorDisplay("Please select a segmentation")
                return

            outputPath = qt.QFileDialog.getSaveFileName(None, "Export Segmentation", "", "NRRD Files (*.nrrd)")
            if outputPath:
                slicer.util.saveNode(segmentationNode, outputPath)
                slicer.util.showStatusMessage("Exported to: " + outputPath, 3000)
        except Exception as e:
            slicer.util.errorDisplay("Failed to export: " + str(e))


class TickSegmentationReviewLogic(ScriptedLoadableModuleLogic):
    """Logic for the module"""

    def __init__(self):
        ScriptedLoadableModuleLogic.__init__(self)

    def setDefaultParameters(self, parameterNode):
        """Initialize parameter node with default values"""
        if not parameterNode.GetParameter("Threshold"):
            parameterNode.SetParameter("Threshold", "100.0")

    def computeStatistics(self, inputVolume, segmentation):
        """
        Compute statistics for each segment
        
        Returns:
            Dictionary with statistics for each segment
        """
        import SegmentStatistics
        
        segStatLogic = SegmentStatistics.SegmentStatisticsLogic()
        segStatLogic.getParameterNode().SetParameter("Segmentation", segmentation.GetID())
        segStatLogic.getParameterNode().SetParameter("ScalarVolume", inputVolume.GetID())
        
        # Compute statistics
        segStatLogic.computeStatistics()
        
        # Get results
        stats = {}
        statsTable = segStatLogic.getStatisticsTable()
        
        for rowIndex in range(statsTable.GetNumberOfRows()):
            segmentId = statsTable.GetValue(rowIndex, 0).ToString()
            stats[segmentId] = {
                'volume_mm3': float(statsTable.GetValue(rowIndex, 1).ToString()),
                'surface_area_mm2': float(statsTable.GetValue(rowIndex, 2).ToString()) if statsTable.GetNumberOfColumns() > 2 else 0,
                'centroid': 'N/A'
            }
        
        return stats


class TickSegmentationReviewTest(ScriptedLoadableModuleTest):
    """Test case for the module"""

    def setUp(self):
        slicer.mrmlScene.Clear()

    def runTest(self):
        self.setUp()
        self.test_TickSegmentationReview1()

    def test_TickSegmentationReview1(self):
        self.delayDisplay("Starting the test")
        self.delayDisplay('Test passed')

